"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/ImageSequence.tsx":
/*!**************************************!*\
  !*** ./components/ImageSequence.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ImageSequence; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction ImageSequence(param) {\n    let { progress } = param;\n    _s();\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [images, setImages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isLoaded, setIsLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Hardcoded for now based on the file list (240 files)\n    const frameCount = 240;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let loadedCount = 0;\n        const imgs = [];\n        const loadImages = async ()=>{\n            for(let i = 1; i <= frameCount; i++){\n                const img = new Image();\n                // Construct filename: ezgif-frame-001.jpg, ezgif-frame-010.jpg, ezgif-frame-100.jpg\n                const frameNumber = i.toString().padStart(3, \"0\");\n                img.src = \"/sequence/ezgif-frame-\".concat(frameNumber, \".jpg\");\n                img.onload = ()=>{\n                    loadedCount++;\n                    if (loadedCount === frameCount) {\n                        setIsLoaded(true);\n                    }\n                };\n                imgs.push(img);\n            }\n            setImages(imgs);\n        };\n        loadImages();\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current || images.length === 0) return;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        // Calculate frame index\n        let frameIndex = Math.floor(progress * (frameCount - 1));\n        // Clamp\n        frameIndex = Math.min(frameCount - 1, Math.max(0, frameIndex));\n        const img = images[frameIndex];\n        // Clear and draw\n        // Use requestAnimationFrame for smoother playback if strictly needed,\n        // but React effect is okay for this scroll-driven approach since progress updates are frequent.\n        if (img && img.complete && img.naturalWidth > 0) {\n            // Draw image covering the canvas while maintaining aspect ratio (object-fit: contain equivalent)\n            // Actually the prompt asks for it to fit cleanly.\n            // Let's just draw it centered.\n            requestAnimationFrame(()=>{\n                // Handle High DPI\n                const dpr = window.devicePixelRatio || 1;\n                // Assume canvas size is set by CSS to window size\n                canvas.width = window.innerWidth * dpr;\n                canvas.height = window.innerHeight * dpr;\n                ctx.scale(dpr, dpr);\n                // Draw Logic\n                const canvasWidth = window.innerWidth;\n                const canvasHeight = window.innerHeight;\n                // Calculate scaling to 'contain' the image\n                const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height);\n                const w = img.width * scale;\n                const h = img.height * scale;\n                const x = (canvasWidth - w) / 2;\n                const y = (canvasHeight - h) / 2;\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.drawImage(img, x, y, w, h);\n            });\n        }\n    }, [\n        progress,\n        images,\n        isLoaded\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n        ref: canvasRef,\n        className: \"block w-full h-full object-contain\",\n        style: {\n            opacity: isLoaded ? 1 : 0,\n            transition: \"opacity 0.5s ease-in-out\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\GWENJE\\\\Downloads\\\\nerdx app download page\\\\components\\\\ImageSequence.tsx\",\n        lineNumber: 89,\n        columnNumber: 9\n    }, this);\n}\n_s(ImageSequence, \"Rmdh9Q97/5wC6OoMqHKPwzdqmH4=\");\n_c = ImageSequence;\nvar _c;\n$RefreshReg$(_c, \"ImageSequence\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvSW1hZ2VTZXF1ZW5jZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRTJEO0FBTTVDLFNBQVNJLGNBQWMsS0FBZ0M7UUFBaEMsRUFBRUMsUUFBUSxFQUFzQixHQUFoQzs7SUFDbEMsTUFBTUMsWUFBWUwsNkNBQU1BLENBQW9CO0lBQzVDLE1BQU0sQ0FBQ00sUUFBUUMsVUFBVSxHQUFHTCwrQ0FBUUEsQ0FBcUIsRUFBRTtJQUMzRCxNQUFNLENBQUNNLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQUM7SUFFekMsdURBQXVEO0lBQ3ZELE1BQU1RLGFBQWE7SUFFbkJULGdEQUFTQSxDQUFDO1FBQ04sSUFBSVUsY0FBYztRQUNsQixNQUFNQyxPQUEyQixFQUFFO1FBRW5DLE1BQU1DLGFBQWE7WUFDZixJQUFLLElBQUlDLElBQUksR0FBR0EsS0FBS0osWUFBWUksSUFBSztnQkFDbEMsTUFBTUMsTUFBTSxJQUFJQztnQkFDaEIsb0ZBQW9GO2dCQUNwRixNQUFNQyxjQUFjSCxFQUFFSSxRQUFRLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO2dCQUM3Q0osSUFBSUssR0FBRyxHQUFHLHlCQUFxQyxPQUFaSCxhQUFZO2dCQUMvQ0YsSUFBSU0sTUFBTSxHQUFHO29CQUNUVjtvQkFDQSxJQUFJQSxnQkFBZ0JELFlBQVk7d0JBQzVCRCxZQUFZO29CQUNoQjtnQkFDSjtnQkFDQUcsS0FBS1UsSUFBSSxDQUFDUDtZQUNkO1lBQ0FSLFVBQVVLO1FBQ2Q7UUFFQUM7SUFDSixHQUFHLEVBQUU7SUFFTFosZ0RBQVNBLENBQUM7UUFDTixJQUFJLENBQUNJLFVBQVVrQixPQUFPLElBQUlqQixPQUFPa0IsTUFBTSxLQUFLLEdBQUc7UUFFL0MsTUFBTUMsU0FBU3BCLFVBQVVrQixPQUFPO1FBQ2hDLE1BQU1HLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUNELEtBQUs7UUFFVix3QkFBd0I7UUFDeEIsSUFBSUUsYUFBYUMsS0FBS0MsS0FBSyxDQUFDMUIsV0FBWU0sQ0FBQUEsYUFBYTtRQUNyRCxRQUFRO1FBQ1JrQixhQUFhQyxLQUFLRSxHQUFHLENBQUNyQixhQUFhLEdBQUdtQixLQUFLRyxHQUFHLENBQUMsR0FBR0o7UUFFbEQsTUFBTWIsTUFBTVQsTUFBTSxDQUFDc0IsV0FBVztRQUU5QixpQkFBaUI7UUFDakIsc0VBQXNFO1FBQ3RFLGdHQUFnRztRQUNoRyxJQUFJYixPQUFPQSxJQUFJa0IsUUFBUSxJQUFJbEIsSUFBSW1CLFlBQVksR0FBRyxHQUFHO1lBQzdDLGlHQUFpRztZQUNqRyxrREFBa0Q7WUFDbEQsK0JBQStCO1lBRS9CQyxzQkFBc0I7Z0JBQ2xCLGtCQUFrQjtnQkFDbEIsTUFBTUMsTUFBTUMsT0FBT0MsZ0JBQWdCLElBQUk7Z0JBQ3ZDLGtEQUFrRDtnQkFDbERiLE9BQU9jLEtBQUssR0FBR0YsT0FBT0csVUFBVSxHQUFHSjtnQkFDbkNYLE9BQU9nQixNQUFNLEdBQUdKLE9BQU9LLFdBQVcsR0FBR047Z0JBQ3JDVixJQUFJaUIsS0FBSyxDQUFDUCxLQUFLQTtnQkFFZixhQUFhO2dCQUNiLE1BQU1RLGNBQWNQLE9BQU9HLFVBQVU7Z0JBQ3JDLE1BQU1LLGVBQWVSLE9BQU9LLFdBQVc7Z0JBRXZDLDJDQUEyQztnQkFDM0MsTUFBTUMsUUFBUWQsS0FBS0UsR0FBRyxDQUFDYSxjQUFjN0IsSUFBSXdCLEtBQUssRUFBRU0sZUFBZTlCLElBQUkwQixNQUFNO2dCQUN6RSxNQUFNSyxJQUFJL0IsSUFBSXdCLEtBQUssR0FBR0k7Z0JBQ3RCLE1BQU1JLElBQUloQyxJQUFJMEIsTUFBTSxHQUFHRTtnQkFDdkIsTUFBTUssSUFBSSxDQUFDSixjQUFjRSxDQUFBQSxJQUFLO2dCQUM5QixNQUFNRyxJQUFJLENBQUNKLGVBQWVFLENBQUFBLElBQUs7Z0JBRS9CckIsSUFBSXdCLFNBQVMsQ0FBQyxHQUFHLEdBQUdOLGFBQWFDO2dCQUNqQ25CLElBQUl5QixTQUFTLENBQUNwQyxLQUFLaUMsR0FBR0MsR0FBR0gsR0FBR0M7WUFDaEM7UUFDSjtJQUNKLEdBQUc7UUFBQzNDO1FBQVVFO1FBQVFFO0tBQVM7SUFFL0IscUJBQ0ksOERBQUNpQjtRQUNHMkIsS0FBSy9DO1FBQ0xnRCxXQUFVO1FBQ1ZDLE9BQU87WUFBRUMsU0FBUy9DLFdBQVcsSUFBSTtZQUFHZ0QsWUFBWTtRQUEyQjs7Ozs7O0FBR3ZGO0dBdEZ3QnJEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvSW1hZ2VTZXF1ZW5jZS50c3g/MjFlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmludGVyZmFjZSBJbWFnZVNlcXVlbmNlUHJvcHMge1xyXG4gICAgcHJvZ3Jlc3M6IG51bWJlcjsgLy8gMCB0byAxXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEltYWdlU2VxdWVuY2UoeyBwcm9ncmVzcyB9OiBJbWFnZVNlcXVlbmNlUHJvcHMpIHtcclxuICAgIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcbiAgICBjb25zdCBbaW1hZ2VzLCBzZXRJbWFnZXNdID0gdXNlU3RhdGU8SFRNTEltYWdlRWxlbWVudFtdPihbXSk7XHJcbiAgICBjb25zdCBbaXNMb2FkZWQsIHNldElzTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBIYXJkY29kZWQgZm9yIG5vdyBiYXNlZCBvbiB0aGUgZmlsZSBsaXN0ICgyNDAgZmlsZXMpXHJcbiAgICBjb25zdCBmcmFtZUNvdW50ID0gMjQwO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbGV0IGxvYWRlZENvdW50ID0gMDtcclxuICAgICAgICBjb25zdCBpbWdzOiBIVE1MSW1hZ2VFbGVtZW50W10gPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgbG9hZEltYWdlcyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZnJhbWVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBmaWxlbmFtZTogZXpnaWYtZnJhbWUtMDAxLmpwZywgZXpnaWYtZnJhbWUtMDEwLmpwZywgZXpnaWYtZnJhbWUtMTAwLmpwZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVOdW1iZXIgPSBpLnRvU3RyaW5nKCkucGFkU3RhcnQoMywgXCIwXCIpO1xyXG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IGAvc2VxdWVuY2UvZXpnaWYtZnJhbWUtJHtmcmFtZU51bWJlcn0uanBnYDtcclxuICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGVkQ291bnQgPT09IGZyYW1lQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2FkZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGltZ3MucHVzaChpbWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldEltYWdlcyhpbWdzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsb2FkSW1hZ2VzKCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50IHx8IGltYWdlcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgZnJhbWUgaW5kZXhcclxuICAgICAgICBsZXQgZnJhbWVJbmRleCA9IE1hdGguZmxvb3IocHJvZ3Jlc3MgKiAoZnJhbWVDb3VudCAtIDEpKTtcclxuICAgICAgICAvLyBDbGFtcFxyXG4gICAgICAgIGZyYW1lSW5kZXggPSBNYXRoLm1pbihmcmFtZUNvdW50IC0gMSwgTWF0aC5tYXgoMCwgZnJhbWVJbmRleCkpO1xyXG5cclxuICAgICAgICBjb25zdCBpbWcgPSBpbWFnZXNbZnJhbWVJbmRleF07XHJcblxyXG4gICAgICAgIC8vIENsZWFyIGFuZCBkcmF3XHJcbiAgICAgICAgLy8gVXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3Igc21vb3RoZXIgcGxheWJhY2sgaWYgc3RyaWN0bHkgbmVlZGVkLFxyXG4gICAgICAgIC8vIGJ1dCBSZWFjdCBlZmZlY3QgaXMgb2theSBmb3IgdGhpcyBzY3JvbGwtZHJpdmVuIGFwcHJvYWNoIHNpbmNlIHByb2dyZXNzIHVwZGF0ZXMgYXJlIGZyZXF1ZW50LlxyXG4gICAgICAgIGlmIChpbWcgJiYgaW1nLmNvbXBsZXRlICYmIGltZy5uYXR1cmFsV2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIERyYXcgaW1hZ2UgY292ZXJpbmcgdGhlIGNhbnZhcyB3aGlsZSBtYWludGFpbmluZyBhc3BlY3QgcmF0aW8gKG9iamVjdC1maXQ6IGNvbnRhaW4gZXF1aXZhbGVudClcclxuICAgICAgICAgICAgLy8gQWN0dWFsbHkgdGhlIHByb21wdCBhc2tzIGZvciBpdCB0byBmaXQgY2xlYW5seS5cclxuICAgICAgICAgICAgLy8gTGV0J3MganVzdCBkcmF3IGl0IGNlbnRlcmVkLlxyXG5cclxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBIaWdoIERQSVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgICAgICAgICAgICAgIC8vIEFzc3VtZSBjYW52YXMgc2l6ZSBpcyBzZXQgYnkgQ1NTIHRvIHdpbmRvdyBzaXplXHJcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAqIGRwcjtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiBkcHI7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERyYXcgTG9naWNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHNjYWxpbmcgdG8gJ2NvbnRhaW4nIHRoZSBpbWFnZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbihjYW52YXNXaWR0aCAvIGltZy53aWR0aCwgY2FudmFzSGVpZ2h0IC8gaW1nLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gaW1nLndpZHRoICogc2NhbGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gaW1nLmhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IChjYW52YXNXaWR0aCAtIHcpIC8gMjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSAoY2FudmFzSGVpZ2h0IC0gaCkgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgeCwgeSwgdywgaCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3Byb2dyZXNzLCBpbWFnZXMsIGlzTG9hZGVkXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Y2FudmFzXHJcbiAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJibG9jayB3LWZ1bGwgaC1mdWxsIG9iamVjdC1jb250YWluXCJcclxuICAgICAgICAgICAgc3R5bGU9e3sgb3BhY2l0eTogaXNMb2FkZWQgPyAxIDogMCwgdHJhbnNpdGlvbjogJ29wYWNpdHkgMC41cyBlYXNlLWluLW91dCcgfX1cclxuICAgICAgICAvPlxyXG4gICAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkltYWdlU2VxdWVuY2UiLCJwcm9ncmVzcyIsImNhbnZhc1JlZiIsImltYWdlcyIsInNldEltYWdlcyIsImlzTG9hZGVkIiwic2V0SXNMb2FkZWQiLCJmcmFtZUNvdW50IiwibG9hZGVkQ291bnQiLCJpbWdzIiwibG9hZEltYWdlcyIsImkiLCJpbWciLCJJbWFnZSIsImZyYW1lTnVtYmVyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsInNyYyIsIm9ubG9hZCIsInB1c2giLCJjdXJyZW50IiwibGVuZ3RoIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZyYW1lSW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJtaW4iLCJtYXgiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRwciIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsInNjYWxlIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJ3IiwiaCIsIngiLCJ5IiwiY2xlYXJSZWN0IiwiZHJhd0ltYWdlIiwicmVmIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJvcGFjaXR5IiwidHJhbnNpdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ImageSequence.tsx\n"));

/***/ })

});